# 🔍 Lock과 트랜잭션 격리 수준( Isolation Level)

**Lock과 트랜잭션 격리 수준(Isolation Level)은 둘 다 동시성 제어(Concurrency Control)를 위한 방법이지만, <br>작동 방식과 목적이 다르다.**

🔹 **Lock**: 특정 트랜잭션이 데이터를 사용하는 동안 **다른 트랜잭션의 접근을 차단하는 메커니즘**

🔹 **격리 수준(Isolation Level)**: 여러 트랜잭션이 동시에 실행될 때 **데이터 일관성을 유지하기 위한 규칙**

---

# **1️⃣ Lock (락)**

### **✅ 개념**

- 락은 트랜잭션이 실행될 때 **특정 데이터(행, 테이블 등)에 대한 접근을 제한하는 기술**
- 주로 **동시에 같은 데이터를 수정하려는 충돌을 방지**하기 위해 사용됨

### **✅ Lock의 종류**

1. **공유 락 (Shared Lock, S Lock)**
    - 데이터를 읽기만 가능
    - 다른 트랜잭션도 읽을 수 있지만, **쓰기(수정)는 불가능**
    - `SELECT ... LOCK IN SHARE MODE` 사용 가능
2. **배타 락 (Exclusive Lock, X Lock)**
    - 데이터를 **읽기+수정 가능**
    - 다른 트랜잭션은 해당 데이터를 읽거나 수정할 수 없음
    - `SELECT ... FOR UPDATE` 사용 가능
3. **의도적 락(Intent Lock)**
    - 트랜잭션이 특정 데이터에 락을 걸려고 할 때, **상위 객체(테이블 등)에 미리 락을 설정하는 방식**
4. **낙관적 락(Optimistic Lock)**
    - 락을 걸지 않고 업데이트할 때 충돌이 발생하면 롤백
    - **버전 번호(Versioning)나 타임스탬프 기반으로 동작**
5. **비관적 락(Pessimistic Lock)**
    - 트랜잭션이 시작될 때 락을 걸어 **다른 트랜잭션의 접근을 방지**

---

### **✅ Lock의 특징**

- 락을 걸면 **다른 트랜잭션이 동일한 데이터에 접근하는 것을 방지할 수 있음**
- *Deadlock(교착 상태)**이 발생할 수 있음 (두 개의 트랜잭션이 서로의 락을 기다리는 경우)
- **수동으로 관리해야 하는 경우가 많음** (ex: `SELECT ... FOR UPDATE`)

---

# **2️⃣ 트랜잭션 격리 수준(Isolation Level)**

### **✅ 개념**

- 여러 트랜잭션이 동시에 실행될 때 **데이터 정합성을 보장하는 정도를 설정하는 규칙**
- 트랜잭션의 동시 실행 문제(Dirty Read, Non-repeatable Read, Phantom Read)를 방지하는 역할

### **✅ 격리 수준의 종류 (낮은 수준 → 높은 수준)**

| 격리 수준                | Dirty Read 방지 | Non-repeatable Read 방지 | Phantom Read 방지 | 동시성 성능   |
|----------------------|---------------|------------------------|-----------------|----------|
| **READ UNCOMMITTED** | ❌ 방지 안됨       | ❌ 방지 안됨                | ❌ 방지 안됨         | 🔥 매우 높음 |
| **READ COMMITTED**   | ✅ 방지          | ❌ 방지 안됨                | ❌ 방지 안됨         | 🔥 높음    |
| **REPEATABLE READ**  | ✅ 방지          | ✅ 방지                   | ❌ 방지 안됨         | ⚡ 보통     |
| **SERIALIZABLE**     | ✅ 방지          | ✅ 방지                   | ✅ 방지            | 🚨 낮음    |

---

## **🔄 Lock vs 트랜잭션 격리 수준(Isolation Level) 비교**

| 비교 항목           | **Lock (락)**                                 | **Isolation Level (격리 수준)**                                |
|-----------------|----------------------------------------------|------------------------------------------------------------|
| **목적**          | 개별 트랜잭션에서 **특정 데이터 보호**                      | 전체 시스템에서 **트랜잭션 간 충돌 관리**                                  |
| **적용 범위**       | **특정 행(Row) 또는 테이블**에 적용                     | **트랜잭션 단위로 격리 수준 결정**                                      |
| **운영 방식**       | 직접 `SELECT ... FOR UPDATE` 같은 명령어로 설정        | DBMS가 내부적으로 관리                                             |
| **동시성**         | 락을 많이 걸수록 동시성이 낮아짐                           | 낮은 격리 수준에서는 동시성이 높아짐                                       |
| **Deadlock 위험** | **높음** (트랜잭션이 서로의 락을 기다릴 경우)                 | **낮음** (격리 수준이 자동 관리됨)                                     |
| **주요 해결 가능 문제** | **Dirty Read, Non-repeatable Read 일부 해결 가능** | **Dirty Read, Non-repeatable Read, Phantom Read 모두 해결 가능** |
| **예제 SQL**      | `SELECT ... FOR UPDATE`                      | `SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;`            |

---

## **🔔 결론: 언제 Lock을 쓰고, 언제 Isolation Level을 조정할까?**

✅ **Isolation Level을 먼저 설정하고, 필요한 경우 추가적으로 Lock을 사용**

✅ **동시성이 중요한 경우 낮은 격리 수준(Read Committed) + Lock을 일부 사용**

✅ **데이터 정합성이 중요한 경우 높은 격리 수준(Repeatable Read, Serializable) 사용**

✅ **Deadlock을 피하려면 Lock보다는 격리 수준 조절이 더 유리**