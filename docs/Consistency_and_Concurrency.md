# 데이터 정합성과 동시성

데이터베이스에서 **데이터 정합성(Consistency)과 동시성(Concurrency)은 서로 상충하는 개념**

데이터 정합성을 강하게 유지하면 동시성이 떨어지고, 동시성을 높이면 정합성이 약해질 수 있다.

---

## **1️⃣ 데이터 정합성(Consistency)**

### **✅ 개념**

- **데이터의 정확성과 신뢰성을 보장하는 것**
- 데이터베이스에 **잘못된 데이터가 저장되거나, 규칙에 어긋나는 변경이 발생하지 않도록 관리**하는 것
- **ACID의 C(Consistency)** 에 해당

### **✅ 정합성이 깨지는 원인**

1. **Dirty Read (더티 리드)**
    - 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 경우
    - 해결 방법: `READ COMMITTED` 이상 격리 수준 설정
2. **Non-repeatable Read (비반복 가능 읽기)**
    - 같은 데이터를 두 번 읽을 때 값이 달라지는 경우
    - 해결 방법: `REPEATABLE READ` 이상 격리 수준 설정
3. **Phantom Read (팬텀 리드)**
    - 같은 조건으로 데이터를 조회했을 때 새로 추가된 데이터가 나타나는 현상
    - 해결 방법: `SERIALIZABLE` 격리 수준 설정
4. **제약 조건 위반 (Constraint Violation)**
    - Primary Key, Foreign Key, Unique Key 등의 데이터 제약 조건이 깨짐

### **✅ 데이터 정합성을 보장하는 방법**

- **트랜잭션 격리 수준 설정** (`READ COMMITTED`, `SERIALIZABLE` 등)
- **ACID(원자성, 일관성, 격리성, 지속성) 준수**
- **데이터 무결성 제약 조건 (PK, FK, UNIQUE, CHECK) 적용**
- **Lock 사용 (`SELECT ... FOR UPDATE`)**
- **MVCC (Multi-Version Concurrency Control) 활용**

---

## **2️⃣ 동시성(Concurrency)**

### **✅ 개념**

- **여러 트랜잭션이 동시에 실행될 수 있는 능력**
- 다중 사용자 환경에서 성능을 높이기 위해 중요
- 동시성을 높이면 여러 트랜잭션이 빠르게 실행되지만, 데이터 정합성이 깨질 가능성이 커짐

### **✅ 동시성 문제의 예시**

1. **Lost Update (손실된 업데이트)**
    - 여러 트랜잭션이 동시에 같은 데이터를 변경할 때, <br>한 트랜잭션의 변경 사항이 다른 트랜잭션에 의해 덮어씌워지는 문제
    - 해결 방법: **Lock 사용**
2. **Dirty Read (더티 리드)**
    - 한 트랜잭션이 **커밋되지 않은 데이터**를 읽는 문제
    - 해결 방법: `READ COMMITTED` 이상 격리 수준 설정
3. **Deadlock (교착 상태)**
    - 두 개 이상의 트랜잭션이 서로 상대방이 가진 락을 기다리면서 **무한 대기 상태**에 빠지는 문제
    - 해결 방법: **트랜잭션 순서 조정, 락 타임아웃 설정**
4. **Non-repeatable Read (일관되지 않은 읽기)**
    - 한 트랜잭션이 데이터를 읽는 동안, 다른 트랜잭션이 데이터를 변경하여 일관성이 깨지는 문제
    - 해결 방법: `REPEATABLE READ` 이상 격리 수준 설정

---

## **3️⃣ 데이터 정합성과 동시성의 관계**

| 비교 항목         | **데이터 정합성 (Consistency)**                | **동시성 (Concurrency)**                   |
|---------------|------------------------------------------|-----------------------------------------|
| **목적**        | 데이터의 신뢰성과 일관성을 유지                        | 여러 트랜잭션을 동시에 실행하여 성능 향상                 |
| **문제 발생 가능성** | 동시성을 높이면 정합성이 깨질 위험이 있음                  | 정합성을 강하게 유지하면 동시성이 낮아짐                  |
| **해결 방법**     | 높은 격리 수준 (SERIALIZABLE) 설정, <br> Lock 사용 | 낮은 격리 수준 (READ COMMITTED), <br> MVCC 사용 |

---

## **4️⃣ 데이터 정합성과 동시성의 균형 유지 방법**

**1️⃣ 트랜잭션 격리 수준 조정**

- **정합성이 중요할 때** → `SERIALIZABLE`, `REPEATABLE READ` 설정
- **동시성이 중요할 때** → `READ COMMITTED` 설정

**2️⃣ 락을 최소화하여 성능 최적화**

- `SELECT ... FOR UPDATE` 사용하지만, 너무 많이 사용하면 동시성이 낮아짐
- 락 범위를 최소화하여 필요한 데이터만 보호

**3️⃣ MVCC (Multi-Version Concurrency Control) 사용**

- `PostgreSQL`, `Oracle`, `InnoDB (MySQL)`에서는 MVCC를 사용하여 **트랜잭션이 서로 영향을 주지 않도록 처리**
- MVCC는 `REPEATABLE READ`에서도 Phantom Read를 방지할 수 있음

**4️⃣ 데드락(Deadlock) 방지 기법 적용**

- 트랜잭션 실행 순서를 조정하여 교착 상태 방지
- 락 타임아웃 설정 (`SET innodb_lock_wait_timeout = 5;`)

---

## **5️⃣ 결론**

✅ **데이터 정합성이 중요한 경우**

- `SERIALIZABLE` 설정 → **가장 강한 트랜잭션 격리 수준 (하지만 성능 저하 가능)**
- `REPEATABLE READ` 사용 → **비반복 읽기 방지 (MVCC 사용하면 Phantom Read도 방지 가능)**

✅ **동시성이 중요한 경우**

- `READ COMMITTED` 설정 → **Dirty Read 방지하면서 성능 유지**
- `READ UNCOMMITTED` 설정 → **가장 빠른 동시성 (정합성이 낮아질 위험 있음)**

✅ **정합성과 동시성을 적절히 조정해야 한다!**

- **은행 거래, 금융 시스템 → 정합성이 중요** → `SERIALIZABLE`
- **SNS, 웹 서비스 → 동시성이 중요** → `READ COMMITTED`