### **1.** 현재 서비스에서 여러 도메인이 관여 되어있는 기능

- 주문 및 결제 메서드(Facade)

    ```java
    사용자 조회
    주문 생성
    주문 상세 정보 생성
    	재고 확인 및 감량
    	주문 상세 정보 생성
    	총 주문 금액 추가
    할인전 최종 금액 설정
    쿠폰 적용
    최종 금액 설정
    결제
    	외부 플랫폼 데이터 전송
    ```

**트랜잭션 흐름 분석**

- 이 메서드는 `@Transactional`이 선언되어 있으므로 **Spring의 트랜잭션 관리**를 받음
- 예외가 발생하면 자동으로 롤백됨.
- 그러나 **외부 API 호출(externalDataPlatformService.sendData) 및 다른 서비스의 트랜잭션 처리 방식**에 따라 부분적으로 롤백이 어려운 상황이 있을 수 있음.

---

### **2. 주요 트랜잭션 단계**

### **(1) 사용자 조회**

- 단순 조회이므로 트랜잭션의 영향을 받지 않음
    - `@Transactional`은 **데이터를 변경하는 SQL(INSERT, UPDATE, DELETE)이 실행되었을 때 트랜잭션을 시작**
- 사용자 조회 단계에서 예외가 발생하면, **트랜잭션이 시작되기도 전에 메서드가 종료되므로 롤백할 데이터 자체가 없음**

---

### **(2) 주문(객체) 생성**

- `orderService.createOrder`에서 주문 정보를 DB에 저장
    - 이때 **주문 ID(order.getId())가 생성되므로, 이후 로직에서 이 주문 ID를 활용함**
    - `order`가 생성된 후, 결제 단계에서 실패하면 주문 정보까지 롤백 됨

---

### **(3) 주문 상세 정보 생성 및 재고 차감**

- 상품의 재고를 확인하고 감소시킴.
    - 차감 이후 문제가 발생하더라도 전체 메서드가 롤백되면 재고도 복구됨.
    - 그러나 **분산 환경(MSA)에서는 롤백이 보장되지 않으므로 보상 트랜잭션이 필요**.

---

### **(4) 쿠폰 적용**

- 쿠폰 사용 처리 (쿠폰 사용 여부 업데이트).
    - 롤백 되면 쿠폰 사용 여부 복구 가능.
    - **쿠폰 사용 후 롤백이 되지 않으면 중복 사용 방지를 위한 추가 로직이 필요**.

---

### **(5) 결제 처리 (포인트 차감 & 결제 생성)**

- **포인트 차감**
    - 롤백 되면 포인트도 복구 가능.
    - 그러나 **MSA 환경에서는 포인트 차감이 실패했을 때 보상 트랜잭션이 필요**.
- 결제(객체) 생성 (`paymentService.createPayment`)
    - 결제 정보를 DB에 저장.
    - 결제가 정상적으로 완료되면 주문 상태를 **COMPLETED**로 변경.

- **결제 성공 후 외부 플랫폼 데이터 전송**
    - **트랜잭션 관리에서 벗어난 부분**.
    - 외부 플랫폼에 데이터 전송을 실패해도 이미 결제가 완료된 상태이므로, 데이터 정합성 문제 발생
    - **재시도 로직 또는 데이터 정합성을 맞추기 위한 로직 필요**.

---

### **(6) 결제 실패 예외 처리**

- 결제가 실패하면 결제 정보를 **FAILED 상태로 저장**.
- **이미 감소된 재고, 차감된 포인트, 사용된 쿠폰은 복구되지 않음.**
    - 이를 해결하려면 **보상 트랜잭션(Compensating Transaction) 또는 Saga 패턴**이 필요.

---

## **트랜잭션 흐름**

```
1. 사용자 조회 (Read) ------------------> [UserService]
2. 주문 생성 (Insert) ------------------> [OrderService]
3. 주문 상세 생성 (Insert) -------------> [OrderDetailService]
4. 재고 감소 (Update) -----------------> [ProductService]
5. 쿠폰 적용 (Update) -----------------> [CouponService]
6. 포인트 차감 (Update) ---------------> [PointService]
7. 결제 처리 (Insert) -----------------> [PaymentService]
8. 주문 상태 변경 (Update) ------------> [OrderService]
9. 외부 데이터 전송 -------------------> [ExternalDataPlatformService]
10. 예외 발생 시 롤백 처리 --------------> [Transactional Rollback]
```

---

## **현재 로직의 한계 및 문제점**

1. **분산 트랜잭션 문제**
    - 포인트 차감, 쿠폰 적용, 재고 감소 등 여러 도메인 서비스에서 DB를 변경하지만, **MSA에서는 DB 트랜잭션을 공유할 수 없음**.
    - **주문이 실패했을 때 쿠폰/포인트/재고를 원래대로 복구해야 함** (보상 트랜잭션 필요).
2. **외부 API 호출 실패 문제**
    - 외부 플랫폼으로 데이터 전송을 실패해도 롤백이 불가능하므로 **별도의 재시도 큐가 필요**.
3. **재고 감소와 주문 생성의 원자성 문제**
    - 재고 감소 후 결제가 실패하면 **재고를 복구해야 함**.
        - **//보상 트랜잭션을 적용하거나 Saga 패턴 사용 필요**.

---

## **해결 방안**

### **1. Saga 패턴 적용**

https://youtu.be/U_TvOgZXK8k?si=2MLRK0uJU9TibEIS

https://youtu.be/bnDvAgfe6Mg?si=dmiWxYA4A4pe5KiM

https://youtu.be/xpwRTu47fqY?si=ek_oTApmv1uF2Ybe

**Saga 패턴:** 분산 시스템(MSA)에서 하나의 비즈니스 프로세스를 여러 서비스에 걸쳐 처리할 때, 데이터 정합성을 보장하기 위해 "연속된 로컬 트랜잭션"과 "보상 트랜잭션"을 활용하는 **트랜잭션 관리 패턴
**

- **Choreography 기반 Saga (이벤트 주도)**

  ![choreography.png](images%2Ftransaction%2Fchoreography.png)

    - **각 서비스가 이벤트를 발행하고 구독하면서(통신하면서) 트랜잭션을 진행하는 방식**
    - 중앙 컨트롤러 없이 **각 서비스가 자체적으로 다음 작업을 수행할 서비스에 이벤트를 전달**
    - **장점**
        - 서비스 간 결합도가 낮고, 확장성이 뛰어남
        - 서비스 수가 적고, 중앙제어가 필요 없는 경우 적합
        - 추가 서비스 생성/소멸에 간섭이 없어 구성이 간편
        - 역할 분산으로 단일 실패 시점이 존재하지 않음
    - **단점**
        - 이벤트 흐름이 복잡해지면 디버깅이 어려울 수 있음
        - 명령추적이 어렵기 때문에 워크플로우 파악이 힘듦
        - 서비스 간의 순환 종속성 발생 가능성 내재
        - 통합 테스트가 어려움

      **📌 Choreography 예제**

      1️⃣ **주문 서비스** → "주문 생성됨" 이벤트 발행

      2️⃣ **결제 서비스** → 주문 생성 이벤트 구독 후, 결제 수행 & "결제 성공" 이벤트 발행

      3️⃣ **재고 서비스** → 결제 성공 이벤트 구독 후, 재고 차감 수행

        ```
        [Order Service] → "Order Created" Event → [Payment Service]
                         → "Payment Completed" Event → [Inventory Service]
        ```

      **🚀 보상 트랜잭션(Compensating Transaction)**

        - 만약 재고차감이 실패하면, **서비스간에 통신으로 다른 서비스의(결제) 취소를 위한 보상 트랜잭션을 실행**
- **Orchestration 기반 Saga (중앙 컨트롤러)**

  ![orchestration.png](images%2Ftransaction%2Forchestration.png)

    - **중앙에서 트랜잭션을 관리하는 Coordinator 서비스(Saga Orchestrator)가 존재**
    - 각 서비스는 Orchestrator의 명령을 받아 작업을 수행하고, 성공 또는 실패 상태를 응답함
    - **장점**
        - 흐름이 명확하고 트랜잭션 관리를 중앙에서 수행할 수 있음
        - 서비스가 많고 복잡한 워크플로우에 적합
        - 프로세스 흐름의 제어 가능
        - 오케스트레이터 존재로 순환 종속성 발생 우려가 없음
        - 한 서비스는 다른 서비스의 명령을 몰라도 됨
    - **단점**
        - Orchestrator가 단일 장애점(SPOF, Single Point of Failure)이 될 가능성이 있음
        - 중앙통제를 위한 복잡한 로직 구현 필요

      **📌 Orchestration 예제**

      1️⃣ **Saga Coordinator** → 주문 서비스에 "주문 생성" 요청

      2️⃣ **주문 서비스** → 성공 후, Coordinator에게 알림

      3️⃣ **Coordinator** → 결제 서비스에 "결제 요청"

      4️⃣ **결제 서비스** → 성공 후, Coordinator에게 알림

      5️⃣ **Coordinator** → 재고 서비스에 "재고 감소 요청"

        ```
        [Orchestrator] → [Order Service] → [Payment Service] → [Inventory Service]
        ```

      **🚀 보상 트랜잭션(Compensating Transaction)**

        - 만약 결제가 실패하면, **Orchestrator가 이전 단계(주문 생성) 취소를 위한 보상 트랜잭션을 실행**