# 🗄️ 캐시(Cache)

## 1. 캐시(Cache)란? 🧐

- **사전적 의미**: `n. 은닉처`
- **CS에서의 의미**: 자주 사용하는 데이터나 값을 미리 복사해 놓는 임시 저장소
- **특징**: 원본 저장소(Data Source, DB)보다 데이터를 빠르게 가져올 수 있는 임시 저장소
- **사용 예시**: Redis, Memcached 등

---

## 2. 캐싱 전략(Cache Strategies) 🎯

요청하는 데이터가 캐시에 있는 경우(**Cache Hit** ✅)는 캐시에서 데이터를 반환하지만, <br>캐시에 없는 경우(**Cache Miss** ❌)는 처리 방식에 따라 다양한 전략이 사용됨

### 2.1. 읽기 집중형 애플리케이션의 캐싱(읽기 전략) 📖

### **1) Look-aside (Cache-aside, Lazy Loading) 🏗️**

- **동작 방식**
    1. 캐시에 데이터가 있을 경우 (`Cache Hit` ✅)
        - 서버 → 캐시 확인 → 캐시 데이터 반환 → 응답
    2. 캐시에 데이터가 없을 경우 (`Cache Miss` ❌)
        - 서버 → 캐시 확인(없음) → DB 조회 → DB 데이터 반환 → 캐시 업데이트 → 응답
- **장점** ✨
    - 애플리케이션의 캐시 제어가 유연함
- **단점** ⚠️
    - 캐시 미스 발생 시 지연 시간이 증가
    - 데이터 갱신 없이 DB를 직접 수정하면 캐시와 데이터 불일치 발생 가능
    - 동시 요청이 발생하면 동일한 데이터를 여러 번 DB에 조회할 가능성 있음

---

### **2) Read-Through 📚**

- **동작 방식**
    - 서버 → 캐시 확인 → (없으면) 캐시가 DB 조회 후 캐시 저장 → 데이터 반환 → 응답
- **장점** ✅
    - 애플리케이션에서 캐싱 로직을 단순화 가능
    - 동시 요청이 있을 경우 캐시가 DB로 단일 쿼리만 전송
- **단점** ⚠️
    - 캐시 갱신 정책을 별도로 관리해야 함

---

### **3) Refresh-Ahead (Coherence의 동작) 🔄**

- **개념**: 캐시 데이터가 만료되기 전에 미리 갱신하는 방식
- **사용 예시**: 핫데이터(Hot Data) 관리, 재접근 가능성이 높은 데이터에 적합 🔥
- **동작 방식**
    1. TTL(만료시간)이 60초, Refresh-Ahead Factor가 0.5일 때
    2. 30초 이전 재접근 → 캐시 데이터 반환
    3. 30~60초 사이 재접근 → 캐시 데이터 반환 후 비동기적으로 DB에서 갱신
    4. 60초 이후 접근 → DB에서 조회 후 캐시 업데이트
- **장점** ✅
    - 캐시 데이터 만료로 인한 Cache Miss를 최소화 가능
- **단점** ⚠️
    - 캐시 갱신 중에도 많은 읽기 요청이 발생할 수 있음

---

### 2.2. 쓰기 집중형 애플리케이션의 캐싱(쓰기 전략) ✍️

### **1) Write-Through 📝**

- **개념**: 캐시를 주요 데이터 저장소로 취급하며, 데이터가 캐시에 먼저 저장된 후 DB에 업데이트됨
- **동작 방식**
    - 서버 → 캐시 데이터 저장 → DB 데이터 저장
- **장점** ✅
    - 캐시 무효화가 거의 발생하지 않음
    - DB와 캐시가 거의 데이터 일관성을 유지함
- **단점** ⚠️
    - 캐시에 모든 데이터가 저장되므로, 드물게 요청되는 데이터도 캐시에 남아 있을 수 있음

---

### **2) Write-Behind ⏳**

- **개념**: Write-Through 방식과 유사하나, DB 업데이트가 비동기적으로 실행됨
- **동작 방식**
    - 서버 → 캐시에 데이터 저장 → (비동기적으로) DB에 데이터 저장
- **장점** ✅
    - 쓰기 성능 향상
    - DB 부하 감소
- **단점** ⚠️
    - 데이터 유실 가능성 존재 (DB 저장이 실패하는 경우)

---

### **3) Write-Around 🔄**

- **개념**: 데이터를 캐시에 저장하지 않고, DB에 먼저 쓰고 비동기적으로 캐시를 업데이트하는 방식
- **동작 방식**
    - 서버 → DB에 데이터 저장 → (비동기적으로) 캐시 업데이트
- **장점** ✅
    - 자주 요청되지 않는 데이터가 캐시에 남아 있지 않음
    - 로그 시스템, 채팅 메시지 등 실시간 데이터 처리에 유리
- **단점** ⚠️
    - Write-Through 대비 읽기 요청 시 Cache Miss 발생 가능성이 높음

---

## 3. 캐시 스탬피드(Cache Stampede) ⚠️

다수의 요청이 동시에 캐시 미스를 발생시켜 데이터베이스 부하가 급격히 증가하는 문제.
<br/>이를 방지하기 위한 방법은 다음과 같음.

### **1) 캐시 만료 시간(Randomized Expiration) ⏳**

- 캐시 데이터의 만료 시간을 랜덤하게 설정하여 특정 순간에 모든 캐시가 동시에 만료되는 것을 방지

### **2) 소프트 만료(Soft Expiration) 🔄**

- 캐시가 만료된 경우에도 이전 데이터를 유지하면서, 비동기적으로 새로운 데이터를 갱신하는 방식

### **3) 배치 로딩(Batch Loading) 📦**

- 동일한 데이터에 대한 다중 요청이 발생할 경우, 한 번의 DB 조회로 여러 요청을 처리하는 방식

### **4) Mutex Locking (분산 락) 🔐**

- Redis의 `SETNX` 등을 사용하여 캐시 갱신을 하나의 프로세스에서만 수행하도록 제어하는 방법