## **🔍 DB의 락(Lock) 종류**

데이터베이스에서 **락(Lock)** 은 <br> **여러 트랜잭션이 동시에 같은 데이터를 조작할 때 데이터의 무결성과 일관성을 유지하기 위해 사용**된다.

락은 다양한 기준에 따라 여러 종류로 분류할 수 있다.

---

## **1️⃣ 락의 범위(Scope)에 따른 분류**

### **🔹 1. 테이블 락 (Table Lock)**

- **테이블 전체에 락을 걸어 다른 트랜잭션의 접근을 차단**
- **공유 테이블 락(SLOCK)**: 읽기는 가능하지만, 쓰기(INSERT, UPDATE, DELETE)는 불가능
- **배타 테이블 락(XLOCK)**: 다른 트랜잭션이 읽기 및 쓰기 모두 불가능

📌 **사용 예시**

```sql
LOCK TABLES users WRITE; -- 테이블 전체에 쓰기 락
UNLOCK TABLES;
```

✅ **장점**: 구현이 간단하고 Deadlock 위험이 적음

❌ **단점**: 동시성이 낮아 성능 저하 가능

---

### **🔹 2. 행(Row) 락 (Record Lock)**

- **테이블이 아닌 특정 레코드(행)에만 락을 설정**
- **동시성을 높일 수 있지만, Deadlock 발생 가능성이 증가**

📌 **사용 예시**

```sql
SELECT *
FROM users
WHERE id = 1 FOR
UPDATE; -- 해당 행에 배타적 락
```

✅ **장점**: 동시성을 높일 수 있음

❌ **단점**: 락 관리 오버헤드 증가, Deadlock 위험

---

### **🔹 3. 페이지 락 (Page Lock)**

- **하나의 데이터 페이지(여러 행이 포함된 블록) 단위로 락을 설정**
- 테이블 락보다 동시성이 높지만, 로우 락보다 낮음

✅ **장점**: 테이블 락보다 동시성이 높음

❌ **단점**: 필요한 레코드보다 더 넓은 범위에 락이 걸릴 수 있음

---

## **2️⃣ 락의 유형(Type)에 따른 분류**

### **🔹 1. 공유 락(Shared Lock, S Lock)**

- 데이터를 **읽기 전용**으로 접근할 때 사용
- 여러 트랜잭션이 동시에 같은 데이터를 읽을 수 있음
- 하지만 **쓰기(UPDATE, DELETE)는 불가능**

📌 **사용 예시**

```sql
SELECT *
FROM users
WHERE id = 1 LOCK IN SHARE MODE; -- 공유 락
```

✅ **장점**: 읽기 작업의 동시성을 높일 수 있음

❌ **단점**: 쓰기 작업이 지연될 수 있음

---

### **🔹 2. 배타 락(Exclusive Lock, X Lock)**

- 데이터를 **읽고 수정할 때** 사용
- 하나의 트랜잭션만 해당 데이터에 접근 가능 (다른 트랜잭션은 접근 불가)

📌 **사용 예시**

```sql
SELECT *
FROM users
WHERE id = 1 FOR
UPDATE; -- 배타적 락
```

✅ **장점**: 데이터 정합성이 보장됨

❌ **단점**: 동시성이 낮아짐

---

### **🔹 3. 의도적 락(Intent Lock)**

- **상위 수준의 락을 획득하기 전에, 하위 수준에서 어떤 유형의 락이 필요한지 미리 선언**
- 주로 **트랜잭션 격리성과 데드락 방지 목적으로 사용**

📌 **의도적 락의 종류**

- **IS (Intent Shared Lock)**: 공유 락을 설정할 의도
- **IX (Intent Exclusive Lock)**: 배타 락을 설정할 의도
- **SIX (Shared Intent Exclusive Lock)**: 공유 락이 걸려 있지만, 특정 행을 배타적으로 변경 가능

✅ **장점**: 락 충돌을 최소화하면서 트랜잭션의 동작을 명확하게 정의

❌ **단점**: 복잡성이 증가

---

## **3️⃣ 트랜잭션 지속성(Duration)에 따른 분류**

### **🔹 1. 즉시 락(Immediate Lock)**

- 트랜잭션이 시작되자마자 락을 설정

---

### **🔹 2. 지연 락(Deferred Lock)**

- 데이터에 실제 접근하기 전까지 락을 설정하지 않음

---

### **🔹 3. 낙관적 락(Optimistic Lock)**

- **락을 걸지 않고 작업을 수행한 후 데이터 변경 시 충돌 검사**
- 충돌이 발생하면 트랜잭션을 롤백하고 다시 시도
- **동시성이 높은 환경에서 성능을 유지하면서 충돌을 방지할 때 유용**

📌 **JPA에서 낙관적 락 사용 예시**

```java

@Entity
public class Account {
    @Id
    @GeneratedValue
    private Long id;

    private Integer balance;

    @Version  // 낙관적 락을 위한 버전 필드
    private Long version;
}
```

✅ **장점**: 락을 최소화하여 동시성 향상

❌ **단점**: 충돌이 많으면 성능 저하 가능

---

### **🔹 4. 비관적 락(Pessimistic Lock)**

- 데이터를 사용할 때 **즉시 락을 걸어 충돌을 방지**
- 충돌 가능성이 높은 환경에서 사용

📌 **JPA에서 비관적 락 사용 예시**

```java
Account account=entityManager.find(Account.class,1L,LockModeType.PESSIMISTIC_WRITE);
```

✅ **장점**: 데이터 정합성을 보장

❌ **단점**: 락을 오래 유지하면 동시성이 저하됨