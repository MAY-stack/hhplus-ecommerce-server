### **1. 인덱스란?**

인덱스(Index)는 데이터베이스에서 검색 성능을 향상시키기 위해 사용하는 자료 구조이다. 책의 색인과 같은 개념으로, 특정 컬럼에 대한 정렬된 정보를 유지하여 검색 속도를 개선한다.

---

### **2. 인덱스의 종류**

### **1) 단일 인덱스(Single Index)**

- 하나의 컬럼을 기준으로 생성된 인덱스
- 검색할 때 해당 컬럼을 사용하면 성능 향상 가능
- `CREATE INDEX idx_name ON table_name(column_name);`

✅ **장점:**

- 특정 컬럼에 대한 검색 성능이 향상됨
- 데이터 삽입, 수정, 삭제 시 인덱스 관리 비용이 상대적으로 적음

❌ **단점:**

- 여러 조건이 포함된 검색에는 비효율적
- 범위 검색 시 활용성이 떨어질 수 있음

---

### **2) 복합 인덱스(Composite Index)**

- 여러 개의 컬럼을 결합하여 만든 인덱스
- 여러 개의 컬럼을 AND 조건으로 검색할 때 효율적
- `CREATE INDEX idx_name ON table_name(col1, col2);`

✅ **장점:**

- 여러 조건을 동시에 만족하는 쿼리의 성능을 향상
- 첫 번째 컬럼을 기준으로 정렬되므로 일부 컬럼만 사용해도 효과를 볼 수 있음

❌ **단점:**

- 인덱스 컬럼 순서가 중요함 (선행 컬럼이 사용되지 않으면 인덱스 활용 어려움)
- 데이터 변경 시 관리 비용 증가

✔ **적용 기준:**

- 자주 사용하는 WHERE 조건에 여러 개의 컬럼이 포함될 경우
- `col1`로 먼저 검색하고, 그 후 `col2`로 필터링하는 경우

---

### **3) 커버링 인덱스(Covering Index)**

- SELECT 조회 시 인덱스만으로 데이터를 가져올 수 있도록 하는 인덱스
- 즉, 테이블에 접근하지 않고 인덱스에서 직접 데이터를 반환할 수 있음
- `CREATE INDEX idx_name ON table_name(col1, col2, col3);`

✅ **장점:**

- 테이블 조회를 생략할 수 있어 성능이 크게 향상됨
- MySQL에서는 **"Using Index"**로 표시됨

❌ **단점:**

- 인덱스 크기가 커질 수 있음
- 너무 많은 컬럼을 포함하면 유지 비용이 증가

✔ **적용 기준:**

- SELECT 대상 컬럼이 모두 인덱스에 포함되어 있을 경우
- 조회 성능이 중요한 경우

---

### **4) 유니크 인덱스(Unique Index)**

- 특정 컬럼이 중복되지 않도록 하는 인덱스
- `CREATE UNIQUE INDEX idx_name ON table_name(column_name);`

✅ **장점:**

- 중복 데이터 삽입 방지 가능
- 검색 성능 향상

❌ **단점:**

- 삽입/수정 시 중복 검사로 인해 성능 저하 가능

✔ **적용 기준:**

- 고유한 값이 보장되어야 하는 경우 (ex. `email`, `username` 등)

---

### **5) 클러스터형 인덱스(Clustered Index)**

- 실제 데이터가 인덱스의 정렬 순서대로 저장되는 방식
- MySQL(InnoDB)에서는 기본적으로 `PRIMARY KEY`가 클러스터형 인덱스로 설정됨

✅ **장점:**

- 범위 검색, ORDER BY 쿼리 성능이 향상됨
- 인덱스가 곧 데이터이므로 추가적인 검색 필요 없음

❌ **단점:**

- 데이터 삽입 순서에 따라 페이지 분할(프래그먼테이션) 발생 가능
- 보조 인덱스(Secondary Index) 조회 시 성능이 저하될 수 있음

✔ **적용 기준:**

- 자주 정렬되는 컬럼을 기준으로 설정
- 기본 키로 자주 조회하는 경우

---

### **6) 비클러스터형 인덱스(Non-Clustered Index)**

- 실제 데이터는 테이블에 저장되고, 인덱스는 별도로 관리됨
- 보조 인덱스(Secondary Index)라고도 함
- 인덱스에서 검색 후 테이블에서 실제 데이터를 가져옴

✅ **장점:**

- 여러 개의 인덱스를 설정할 수 있어 다양한 검색 패턴 지원 가능

❌ **단점:**

- 테이블을 추가로 조회해야 하므로 성능 저하 가능

✔ **적용 기준:**

- WHERE 조건에서 자주 사용되지만, 클러스터형 인덱스가 아닌 경우

---

### **3. 인덱스 설정 기준**

1. **자주 사용하는 컬럼에 인덱스를 생성**
    - WHERE, JOIN, ORDER BY, GROUP BY 등에 자주 사용되는 컬럼
2. **카디널리티(중복도)가 낮은 컬럼에 인덱스 사용**
    - 예: `성별(M/F)` 같은 값은 중복이 많아 인덱스 효과가 적음
    - 반면, `주문번호(order_id)` 같은 고유한 값은 효과적
3. **읽기 성능을 개선하는 경우 사용**
    - SELECT 쿼리가 많은 경우 인덱스 추가가 효과적
    - INSERT/UPDATE/DELETE가 많다면 인덱스 유지 비용이 증가하므로 신중하게 고려
4. **인덱스 컬럼 순서 최적화**
    - 복합 인덱스를 사용할 때 자주 사용하는 순서로 컬럼을 배치해야 함
    - 예: `(A, B, C)` 인덱스가 있으면 `A`로 검색할 때는 사용 가능하지만, `B`로만 검색할 때는 사용 불가능
5. **커버링 인덱스를 활용해 테이블 조회 최소화**
    - SELECT하는 컬럼을 인덱스에 포함하여 테이블 조회를 줄이는 것이 효과적

---

### **4. 인덱스의 장단점**

✅ **장점:**

- 검색 성능 향상
- WHERE, JOIN, ORDER BY, GROUP BY 연산 속도 증가
- 커버링 인덱스를 활용하면 테이블 접근 없이 데이터 조회 가능

❌ **단점:**

- INSERT/UPDATE/DELETE 성능 저하 (인덱스 유지 비용 증가)
- 너무 많은 인덱스는 오히려 성능 저하를 유발
- 데이터 변경이 빈번한 컬럼에는 적합하지 않음

---