# 📌 이커머스 서비스의 캐싱 적용 및 성능 개선

이커머스 서비스에서는 데이터베이스 부하를 줄이고 응답 속도를 개선하기 위해 Redis를 활용한 캐싱 전략을 적용할 수 있다. 아래는 주요 캐싱 대상과 개선 방안을 정리한 문서이다.

---

## 1. 캐싱 적용 대상 분석

### 1.1 🛍️ 상품 조회 (Product Lookup)

**개선 방법:**
상품 데이터를 Redis에 캐싱하여 데이터베이스 조회 부담을 줄인다.

**이유:**

- 상품 정보는 자주 조회되지만, 상대적으로 변경이 적음.
- DB 부하 감소 및 빠른 응답 속도 제공.

### 1.2 📂 카테고리별 상품 목록 조회 (Category Product List)

**개선 방법:**
카테고리별 상품 목록을 Redis에 저장하고, 변경 발생 시만 갱신.

**이유:**

- 많은 사용자 요청이 집중되는 주요 API.
- 페이지네이션 데이터 캐싱으로 응답 속도 향상.

### 1.3 📈 인기 상품 리스트 (Best Seller, Trending Items)

**개선 방법:**
Redis Sorted Set을 이용해 랭킹 데이터를 관리.

**이유:**

- 실시간으로 갱신되는 데이터이지만, DB에서 매번 집계하면 부담이 큼.
- Redis는 ZSET을 이용해 효율적으로 정렬된 데이터를 제공.

### 1.4 🎟️ 선착순 쿠폰 발급 (First-Come, First-Served Coupon Issuance)

**개선 방법:**
Redis의 DECRBY 연산을 활용하여 쿠폰 잔여 수량을 관리하고, 사용자 발급 여부를 SADD를 이용해 검증.

**이유:**

- 대량 트래픽에서 선착순 쿠폰 발급 로직을 빠르게 처리하기 위함.
- Redis의 원자적 연산을 활용하여 동시성 문제를 해결 가능.

### 1.5 🛒 장바구니 (Shopping Cart)

**개선 방법:**
Redis의 Hash 자료구조를 활용하여 장바구니 데이터를 저장.

**이유:**

- 세션별 유지되며 영구 저장이 필요하지 않음.
- 빠른 조회와 수정이 요구되므로 Redis가 적합.

### 1.6 🔐 세션 및 로그인 상태 관리

**개선 방법:**
Redis를 세션 저장소로 사용.

**이유:**

- 세션 데이터는 짧은 기간 유지되며, 빠른 접근 속도가 중요.
- DB 부하를 줄이고, 분산 환경에서 세션 공유가 가능해짐.

### 1.7 🚀 주문 진행 상태 관리 (Order Processing)

**개선 방법:**
Redis의 Pub/Sub 또는 Stream을 이용한 상태 관리.

**이유:**

- 주문 처리는 비동기적으로 진행되며, 실시간 처리가 요구됨.
- 메시지 큐 역할을 수행할 수 있어 성능 최적화 가능.

---

## 2. ⚠️ 캐싱 적용 시 고려할 점

1. **데이터 일관성 유지:**
    - Redis에 저장된 쿠폰 잔여 수량과 DB의 실제 데이터 간의 불일치를 방지하기 위해 주기적으로 동기화 필요.
    - TTL을 설정하여 만료되면 자동으로 재동기화되도록 구성 가능.
2. **쿠폰 발급 실패 시 롤백 처리:**
    - Redis에서 `DECRBY` 수행 후 최종 DB에 발급 데이터 저장 시 실패하면 다시 `INCRBY`를 수행하여 롤백 필요.
3. **동시성 문제 해결:**
    - Redis 분산 락(Redisson)을 활용하여 특정 쿠폰 ID에 대해 발급 처리를 하나의 스레드가 처리하도록 제한 가능.
    - `Lua Script`를 사용하여 `잔여 수량 확인 → 차감`을 원자적으로 수행.

---

## 3. ⚡ 구현한 캐싱 로직

### 🎯 개선 방안

### 🎟️ 1. 쿠폰 발급 로직 (Redis 활용)

**기존 방식:**

1. `userId`와 `couponId`를 인자로 받음.
2. `userId`로 사용자를 조회.
3. `couponId`로 DB에서 잔여 수량을 조회.
4. 쿠폰이 남아있다면 `UPDATE` 쿼리를 실행하여 잔여 수량 감소.
5. `userId`와 `couponId`를 DB에서 조회하여 중복 발급 여부 확인.
6. 쿠폰을 DB에 저장.

**개선 방식:**

1. `userId`와 `couponId`를 인자로 받음.
2. `userId`로 사용자를 조회.
3. `couponId`로 Redis에서 `coupon:remaining:quantity:{couponId}` 값을 감소 (`DECRBY`).
4. `userId`와 `couponId`로 쿠폰을 발급:
    - Redis의 `coupon:issued:user:{couponId}`에서 `userId` 존재 여부 확인.
    - 쿠폰을 DB에 저장.
    - Redis의 `coupon:issued:user:{couponId}`에 `userId` 추가.
5. Scheduler를 통해 Redis의 쿠폰 잔여 수량과 DB의 쿠폰 잔여 수량을 동기화.

**이점:**

- Redis를 활용하여 빠른 조회 및 처리 가능.
- 동시성 문제를 방지하고, 부하를 줄일 수 있음.
- Scheduler를 통해 데이터 일관성을 유지.